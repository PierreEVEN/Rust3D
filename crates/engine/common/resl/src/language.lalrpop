use std::str::FromStr;
use crate::ast::{*};

grammar;

match { // Skipped items
    r"[\s\n]*" => { }, // whitespace
    r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { }, // `/* comment */`
}
else { // Reserved names
    "#pragma" => pragma,
    r"#define[^\n]+" => define,
    "global" => global,
    "vertex" => vertex,
    "fragment" => fragment,
    "compute" => compute,
    r"(struct|cbuffer)" => struct,
}
else { // Other tokens
    r"[0-9]+" => INTEGER,
    r"[a-zA-Z][a-zA-Z0-9_]*" => WORD,
    r#""[^"]*""# => QUOTED_STRING,
    r";" => SEMICOLON,
    "{" => BRACKET_OPEN,
    r"(};)|}" => BRACKET_CLOSE,
    r"register\([^)]+\)" => register,
}
else {
    _
}

// SHB PARSER

pub InstructionList: ListOf<Instruction> = {
    <new:Instruction> => ListOf::<Instruction>::new().push(<>),
    <last:InstructionList> <new:Instruction> => last.push(new)
}

Instruction : Instruction = {
    Pragma => <>,
    global "(" <wl:PassList> ")" BRACKET_OPEN <hlsl:HLSL_CODE> BRACKET_CLOSE => Instruction::Global(wl, hlsl),
    vertex "(" <wl:PassList> ")" BRACKET_OPEN <hlsl:HLSL_CODE> BRACKET_CLOSE => Instruction::Vertex(wl, hlsl),
    fragment "(" <wl:PassList> ")" BRACKET_OPEN <hlsl:HLSL_CODE> BRACKET_CLOSE => Instruction::Fragment(wl, hlsl),
    compute "(" <wl:PassList> ")" BRACKET_OPEN <hlsl:HLSL_CODE> BRACKET_CLOSE => Instruction::Compute(wl, hlsl),
}

PassList : RenderPassGroup = {
    <v:String> => RenderPassGroup::new().add(v),
    <pl:PassList> "," <v:String> => pl.add(v)
}

Pragma: Instruction = {
    pragma <name:Word> <value:Value> => Instruction::Pragma(name, value),
    pragma <name:Word> => Instruction::Pragma(name, Value::None)
}

Word : String = {
    WORD => <>.to_string()
}

Value : Value = {
    INTEGER => Value::Integer(i64::from_str(<>).unwrap()),
    String => Value::String(<>),
}

String : String = {
    Word => <>,
    QUOTED_STRING => <>[1..<>.len() - 1].to_string()
}

// HLSL PARSER

HLSL_CODE : ListOf<HlslInstruction> = {
    <v:HlslInstruction> => ListOf::<HlslInstruction>::new().push(v),
    <hl:HLSL_CODE> <v:HlslInstruction> => hl.push(v)
}

HlslInstruction : HlslInstruction = {
    struct <name:Word> BRACKET_OPEN <fields:StructureFieldList> BRACKET_CLOSE => HlslInstruction::Struct(name, fields),
    struct <name:Word> ":" register BRACKET_OPEN <fields:StructureFieldList> BRACKET_CLOSE => HlslInstruction::Struct(name, fields),
    define => HlslInstruction::Define(<>.to_string()),
    <return_type:Word> <name:Word> "(" <params:FunctionParameterList> ")" BRACKET_OPEN <content:FunctionContent> BRACKET_CLOSE => HlslInstruction::Function(name, Function { return_type, params, content} ),
    <return_type:Word> <name:Word> "(" <params:FunctionParameterList> ")" ":" Word BRACKET_OPEN <content:FunctionContent> BRACKET_CLOSE => HlslInstruction::Function(name, Function { return_type, params, content} ),
    <prop_type:Word> <name:Word> SEMICOLON => HlslInstruction::Property(prop_type, name),
    <prop_type:Word> <name:Word> ":" register SEMICOLON => HlslInstruction::Property(prop_type, name),
}

StructureFieldList : ListOf<StructureField> = {
    StructureField => ListOf::<StructureField>::new().push(<>),
    <sfl:StructureFieldList> <sf:StructureField> => sfl.push(sf)
}

StructureField : StructureField = {
    <struct_type:Word> <name:Word> SEMICOLON => StructureField {struct_type, name, value: None, attribute:None},
    <struct_type:Word> <name:Word> ":" <attribute:Word> SEMICOLON => StructureField {struct_type, name, value: None, attribute: Some(attribute)},
    <struct_type:Word> <name:Word> "[" WORD "]" SEMICOLON => StructureField {struct_type, name, value: None, attribute: None},
}

FunctionParameterList : ListOf<FunctionParameter> = {
    FunctionParameter => ListOf::<FunctionParameter>::new().push(<>),
    <sfl:FunctionParameterList> "," <sf:FunctionParameter> => sfl.push(sf)
}

FunctionParameter : FunctionParameter = {
    <param_type:Word> <name:Word> => FunctionParameter {param_type, name},
    <param_type:Word> <name:Word> ":" Word => FunctionParameter {param_type, name}
}

FunctionContent : ListOf<HlslCodeBlock> = {
    AllUntilSemicolon => <>,
    <a:FunctionContent> <b:AllUntilSemicolon> => {
        let mut var = b;
        a.concat(&mut var)
    },
}

AllUntilSemicolon : ListOf<HlslCodeBlock> = {
    SEMICOLON => ListOf::<HlslCodeBlock>::new().push(HlslCodeBlock::Semicolon),
    <a:INTEGER> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Text(a.to_string())),
    <a:WORD> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Text(a.to_string())),
    <a:QUOTED_STRING> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Text(a.to_string())),
    <a:r"[^}{]"> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(a.chars().nth(0).unwrap())),
    <a:"("> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(a.chars().nth(0).unwrap())),
    <a:")"> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(a.chars().nth(0).unwrap())),
    <a:"."> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(a.chars().nth(0).unwrap())),
    <a:"]"> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(a.chars().nth(0).unwrap())),
    <a:"["> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(a.chars().nth(0).unwrap())),
    <a:","> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(a.chars().nth(0).unwrap())),
    <a:":"> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(a.chars().nth(0).unwrap())),
    BRACKET_OPEN <b:FunctionContent> BRACKET_CLOSE => ListOf::<HlslCodeBlock>::new().push(HlslCodeBlock::InnerBlock(b))
}