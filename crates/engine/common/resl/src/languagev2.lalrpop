use std::str::FromStr;
use crate::ast::{*};

grammar;

match {
    r"[\s]*" => { }, // Skip whitespace and comments
    r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { }, // `/* comment */`
    _ // Everything else
}

// SHB PARSER

pub InstructionList: ListOf<Instruction> = {
    <new:Instruction> => ListOf::<Instruction>::new().push(<>),
    <last:InstructionList> <new:Instruction> => last.push(new)
}

Instruction : Instruction = {
    Pragma => <>,
    "global" "(" <wl:PassList> ")" "{" <hlsl:HLSL_CODE> "}" => Instruction::Global(wl, hlsl),
    "vertex" "(" <wl:PassList> ")" "{" <hlsl:HLSL_CODE> "}" => Instruction::Vertex(wl, hlsl),
    "fragment" "(" <wl:PassList> ")" "{" <hlsl:HLSL_CODE> "}" => Instruction::Fragment(wl, hlsl),
    "compute" "(" <wl:PassList> ")" "{" <hlsl:HLSL_CODE> "}" => Instruction::Compute(wl, hlsl),
}

PassList : RenderPassGroup = {
    <v:String> => RenderPassGroup::new().add(v),
    <pl:PassList> "," <v:String> => pl.add(v)
}

Pragma: Instruction = {
    "#pragma" <name:Word> <value:Value> => Instruction::Pragma(name, value),
    "#pragma" <name:Word> => Instruction::Pragma(name, Value::None)
}

Word : String = {
    r"[a-zA-Z][a-zA-Z0-9_]*" => <>.to_string() // Single word
}

Value : Value = {
    r"[0-9]+" => Value::Integer(i64::from_str(<>).unwrap()),
    String => Value::String(<>),
}

String : String = {
    Word => <>, // One word string
    QuotedString => <>
}

QuotedString : String = {
    r#""[^"]*""# => <>[1..<>.len() - 1].to_string() // Quoted string
}

// HLSL PARSER

HLSL_CODE : ListOf<HlslInstruction> = {
    <v:HlslInstruction> => ListOf::<HlslInstruction>::new().push(v),
    <hl:HLSL_CODE> <v:HlslInstruction> => hl.push(v)
}

HlslInstruction : HlslInstruction = {
    "struct" <name:Word> "{" <fields:StructureFieldList> "}" => HlslInstruction::Struct(name, fields),
    //<return_type:Word> <name:Word> "(" <params:FunctionParameterList> ")" <content:FunctionContent> => HlslInstruction::Function(name, Function { return_type, params: vec![], content} ),
}

//FunctionContentBlock : String = {
//    r#"\{[^{}"]*}"# => <>.to_string()
//}

StructureFieldList : ListOf<StructureField> = {
    StructureField => ListOf::<StructureField>::new().push(<>),
    <sfl:StructureFieldList> <sf:StructureField> => sfl.push(sf)
}

StructureField : StructureField = {
    <struct_type:Word> <name:Word> ";" => StructureField {struct_type, name, value: None, attribute:None},
    <struct_type:Word> <name:Word> ":" <attribute:"[^;]+;"> => StructureField {struct_type, name, value: None, attribute: Some(attribute.to_string())},
    <struct_type:Word> <name:Word> ":" <attribute:Word> ";" => StructureField {struct_type, name, value: None, attribute: Some(attribute)},
}

FunctionParameterList : ListOf<FunctionParameter> = {
    FunctionParameter => ListOf::<FunctionParameter>::new().push(<>),
    <sfl:FunctionParameterList> "," <sf:FunctionParameter> => sfl.push(sf)
}

FunctionContent : String = {
    FunctionBlock => <>.to_string(),
    <a:FunctionContent> <b:FunctionBlock> => a + b.as_str()
}

FunctionBlock : String = {
    QuotedString => <>,
    "{" <content:FunctionContent> "}" => ("{".to_string() + content.as_str()) + "}"
}

FunctionParameter : FunctionParameter = {
    <param_type:Word> <name:Word> => FunctionParameter {param_type, name}
}