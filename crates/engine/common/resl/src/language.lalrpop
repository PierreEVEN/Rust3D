use std::str::FromStr;
use crate::ast::{*};
use crate::list_of::{*};
use shader_base::ShaderStage;

grammar;

match { // Skipped items
    r"[\s\n]*" => { }, // whitespace
    r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { }, // `/* comment */`
}
else { // Reserved names
    "#version" => version,
    "#pragma" => pragma,
    r"#define[^\n]+" => define,
    r"#include[^\n]+" => include,
    "global" => global,
    "vertex" => vertex,
    "fragment" => fragment,
    "compute" => compute,
    r"(struct|cbuffer)" => struct,
}
else { // Hlsl types
    r"[a-zA-Z][a-zA-Z0-9_]*<([a-zA-Z][a-zA-Z0-9_]|,)*>" => template_type,
}
else { // Other tokens
    r"[0-9]*\.[0-9]+f?" => FLOAT,
}
else {
    r"[0-9]+" => INTEGER,
}
else {
    r"[a-zA-Z][a-zA-Z0-9_]*" => WORD,
    r#""[^"]*""# => QUOTED_STRING,
    r";" => SEMICOLON,
    "{" => BRACKET_OPEN,
    r"(};)|}" => BRACKET_CLOSE,
    r"register\([^)]+\)" => register,
}
else {
    _
}

// SHB PARSER

pub InstructionList: ListOf<Instruction> = {
    <new:Instruction> => ListOf::<Instruction>::new().push(<>),
    <last:InstructionList> <new:Instruction> => last.push(new)
}

Instruction : Instruction = {
    <t:@L> version <i:INTEGER> => Instruction::Version(t, u64::from_str(i).unwrap()),
    Pragma => <>,
    <t:@L> global "(" <wl:PassList> ")" BRACKET_OPEN <hlsl:HLSL_CODE> BRACKET_CLOSE => Instruction::Global(t, wl, hlsl),
    <t:@L> vertex "(" <wl:PassList> ")" BRACKET_OPEN <hlsl:HLSL_CODE> BRACKET_CLOSE => Instruction::Block(t, ShaderStage::Vertex, wl, hlsl),
    <t:@L> fragment "(" <wl:PassList> ")" BRACKET_OPEN <hlsl:HLSL_CODE> BRACKET_CLOSE => Instruction::Block(t, ShaderStage::Fragment, wl, hlsl),
    <t:@L> compute "(" <wl:PassList> ")" BRACKET_OPEN <hlsl:HLSL_CODE> BRACKET_CLOSE => Instruction::Block(t, ShaderStage::Compute, wl, hlsl),
}

PassList : RenderPassGroup = {
    <v:String> => RenderPassGroup::new().add(v),
    <pl:PassList> "," <v:String> => pl.add(v)
}

Pragma: Instruction = {
    <t:@L> pragma <name:Word> <value:Value> => Instruction::Pragma(t, name, value),
    <t:@L> pragma <name:Word> => Instruction::Pragma(t, name, Value::None)
}

Word : String = {
    WORD => <>.to_string()
}

Value : Value = {
    INTEGER => Value::Integer(i64::from_str(<>).unwrap()),
    FLOAT => Value::Float(<>.to_string()),
    String => Value::String(<>),
}

String : String = {
    Word => <>,
    QUOTED_STRING => <>[1..<>.len() - 1].to_string()
}

// HLSL PARSER

HLSL_CODE : ListOf<HlslInstruction> = {
    <v:HlslInstruction> => ListOf::<HlslInstruction>::new().push(v),
    <hl:HLSL_CODE> <v:HlslInstruction> => hl.push(v)
}

HlslInstruction : HlslInstruction = {
    <t:@L> struct <name:Word> BRACKET_OPEN <fields:StructureFieldList> BRACKET_CLOSE => HlslInstruction::Struct(t, name, None, fields),
    <t:@L> struct <name:Word> ":" <register:register> BRACKET_OPEN <fields:StructureFieldList> BRACKET_CLOSE => HlslInstruction::Struct(t, name, Some(Register::new(register)), fields),
    <t:@L> <def:define> => {
        let mut name = String::new();
        let mut value = String::new();
        let mut started_name = false;
        let mut finished_name = false;
        let mut was_space = false;
        for i in 7..def.len() {
            let char = def.chars().nth(i).unwrap();
            if (char == ' ' || char == '\t') && !finished_name {
                if was_space { continue; }
                if !started_name { started_name = true; } else { finished_name = true }
                was_space = true;
            } else {
                was_space = false;
                if !finished_name { name.push(char); } else { value.push(char); }
            }
        }
        HlslInstruction::Define(t, name, if value.is_empty() { None } else { Some(value) })
    },
    <t:@L> include => HlslInstruction::Include(t, <>.to_string()),
    <t:@L> <return_type:HlslType> <name:Word> "(" <params:FunctionParameterList> ")" <beg:@L> BRACKET_OPEN <content:FunctionContent> BRACKET_CLOSE <end:@R> => HlslInstruction::Function(t, name, Function { return_type: (t, return_type), attribute: None, params, content: (beg, end, content)} ),
    <t:@L> <return_type:HlslType> <name:Word> "(" <params:FunctionParameterList> ")" ":" <at_loc:@L> <attribute:Word> <beg:@L> BRACKET_OPEN <content:FunctionContent> BRACKET_CLOSE <end:@R> => HlslInstruction::Function(t, name, Function { return_type: (t, return_type), attribute: Some((at_loc, attribute)), params, content: (beg, end, content)} ),
    <t:@L> <return_type:HlslType> <name:Word> "(" <params:FunctionParameterList> ")" <beg:@L> BRACKET_OPEN BRACKET_CLOSE <end:@R>  => HlslInstruction::Function(t, name, Function { return_type: (t, return_type), attribute: None, params, content: (beg, end, ListOf::<HlslCodeBlock>::new())} ),
    <t:@L> <return_type:HlslType> <name:Word> "(" <params:FunctionParameterList> ")" ":" <at_loc:@L> <attribute:Word> <beg:@L> BRACKET_OPEN BRACKET_CLOSE <end:@R> => HlslInstruction::Function(t, name, Function { return_type: (t, return_type), attribute: Some((at_loc, attribute)), params, content:(beg, end, ListOf::<HlslCodeBlock>::new())} ),
    
    <t:@L> <prop_type:HlslType> <name:Word> SEMICOLON => HlslInstruction::Property(t, prop_type, name, None),
    <t:@L> <prop_type:HlslType> <name:Word> ":" <register:register> SEMICOLON => HlslInstruction::Property(t, prop_type, name, Some(Register::new(register))),
}

StructureFieldList : ListOf<StructureField> = {
    StructureField => ListOf::<StructureField>::new().push(<>),
    <sfl:StructureFieldList> <sf:StructureField> => sfl.push(sf)
}

StructureField : StructureField = {
    <token:@L> <struct_type:HlslType> <name:Word> SEMICOLON => StructureField {token, struct_type, name, value: None, attribute:None},
    <token:@L> <struct_type:HlslType> <name:Word> ":" <attribute:Word> SEMICOLON => StructureField {token,struct_type, name, value: None, attribute: Some(attribute)},
    <token:@L> <struct_type:HlslType> <name:Word> "[" WORD "]" SEMICOLON => StructureField {token, struct_type, name, value: None, attribute: None},
}

FunctionParameterList : ListOf<FunctionParameter> = {
    FunctionParameter => ListOf::<FunctionParameter>::new().push(<>),
    <sfl:FunctionParameterList> "," <sf:FunctionParameter> => sfl.push(sf)
}

FunctionParameter : FunctionParameter = {
    <a:@L> <param_type:HlslType> <b:@L> <name:Word> => FunctionParameter {param_type:(a, param_type), name:(b, name), attribute:None},
    <a:@L> <param_type:HlslType> <b:@L> <name:Word> ":" <c:@L> <attribute:Word> => FunctionParameter {param_type:(a, param_type), name:(b, name), attribute:Some((c, attribute))}
}

FunctionContent : ListOf<HlslCodeBlock> = {
    AllUntilSemicolon => <>,
    <a:FunctionContent> <b:AllUntilSemicolon> => {
        let mut var = b;
        a.concat(&mut var)
    },
}

HlslType : HlslType = {
    WORD => HlslType::from(<>),
    template_type => HlslType::from(<>),
}

AllUntilSemicolon : ListOf<HlslCodeBlock> = {
    <t:@L> SEMICOLON => ListOf::<HlslCodeBlock>::new().push(HlslCodeBlock::Semicolon(t)),
    <t:@L> <a:INTEGER> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Text(t, a.to_string())),
    <t:@L> <a:FLOAT> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Text(t, a.to_string())),
    <t:@L> <a:WORD> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Text(t, a.to_string())),
    <t:@L> <a:template_type> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Text(t, a.to_string())),
    <t:@L> <a:QUOTED_STRING> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Text(t, a.to_string())),
    <t:@L> <a:r"[^}{]"> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(t, a.chars().nth(0).unwrap())),
    <t:@L> <a:"("> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(t, a.chars().nth(0).unwrap())),
    <t:@L> <a:")"> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(t, a.chars().nth(0).unwrap())),
    <t:@L> <a:"."> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(t, a.chars().nth(0).unwrap())),
    <t:@L> <a:"]"> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(t, a.chars().nth(0).unwrap())),
    <t:@L> <a:"["> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(t, a.chars().nth(0).unwrap())),
    <t:@L> <a:","> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(t, a.chars().nth(0).unwrap())),
    <t:@L> <a:":"> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(t, a.chars().nth(0).unwrap())),
    <t:@L> <a:">"> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(t, a.chars().nth(0).unwrap())),
    <t:@L> <a:"<"> <b:AllUntilSemicolon> => b.push_front(HlslCodeBlock::Token(t, a.chars().nth(0).unwrap())),
    <t:@L> BRACKET_OPEN <b:FunctionContent> <v:@L> BRACKET_CLOSE => ListOf::<HlslCodeBlock>::new().push(HlslCodeBlock::InnerBlock(t, v, b)),
}