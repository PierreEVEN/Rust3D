
#version 1
#pragma float_v 4.5
#pragma once twice
#pragma test two
#pragma ENABLE_HLSL
#pragma integer 4
#pragma version "4.5.8.9 test"

global(test, "shader a", shader_b) {

    struct VSInput
    {
        float2 aPos 	: POSITION;
        float2 aUV 		: TEXCOORD;
        float4 aColor 	: COLOR;
    }

    struct PushConsts
    {
        float2 uScale;
        float2 uTranslate;
    }

    // pixel shader function
    float4 pixelShader(v2p input) : SV_TARGET
    {
        float4 color = tex2D(MyTexture, input.uv);
        return color * input.color;
    }
}

vertex(example) {
    // declaration of functions

    // data structure : before vertex shader (mesh info)
    struct vertexInfo
    {
        float3 position : POSITION;
        float2 uv: TEXCOORD0;
        float3 color : COLOR;
    }

    // data structure : vertex shader to pixel shader
    // also called interpolants because values interpolates through the triangle
    // from one vertex to another
    struct v2p
    {
        float4 position : SV_POSITION;
        float3 uv : TEXCOORD0;
        float3 color : TEXCOORD1;
    }

    // uniforms : external parameters
    sampler2D MyTexture;
    float2 UVTile;
    matrix4x4 worldViewProjection;

    // vertex shader function
    v2p vertexShader(vertexInfo input)
    {
        v2p output;
        output.position = mul(worldViewProjection, float4(input.position,1.0));
        output.uv = input.uv * UVTile;
        output.color = input.color;
        return output;
    }

    // pixel shader function
    float4 pixelShader(v2p input) : SV_TARGET
    {
        float4 color = tex2D(MyTexture, input.uv);
        return color * input.color;
    }
}

fragment(all, none) {
    Texture2D shadowMap : register(t0);
    Texture2D diffuseMap : register(t1);
    Texture2D normalMap : register(t2);

    SamplerState sampleWrap : register(s0);
    SamplerState sampleClamp : register(s1);

    #define NUM_LIGHTS 3
    #define SHADOW_DEPTH_BIAS 0.00005f

    struct LightState
    {
        float3 position;
        float3 direction;
        float4 color;
        float4 falloff;
        float4x4 view;
        float4x4 projection;
    };

    cbuffer SceneConstantBuffer : register(b0)
    {
        float4x4 model;
        float4x4 view;
        float4x4 projection;
        float4 ambientColor;
        bool sampleShadowMap;
        LightState lights[NUM_LIGHTS];
    };

    struct PSInput
    {
        float4 position : SV_POSITION;
        float4 worldpos : POSITION;
        float2 uv : TEXCOORD0;
        float3 normal : NORMAL;
        float3 tangent : TANGENT;
    };


    //--------------------------------------------------------------------------------------
    // Sample normal map, convert to signed, apply tangent-to-world space transform.
    //--------------------------------------------------------------------------------------
    float3 CalcPerPixelNormal(float2 vTexcoord, float3 vVertNormal, float3 vVertTangent)
    {
        // Compute tangent frame.
        vVertNormal = normalize(vVertNormal);
        vVertTangent = normalize(vVertTangent);

        float3 vVertBinormal = normalize(cross(vVertTangent, vVertNormal));
        float3x3 mTangentSpaceToWorldSpace = float3x3(vVertTangent, vVertBinormal, vVertNormal);

        // Compute per-pixel normal.
        float3 vBumpNormal = (float3)normalMap.Sample(sampleWrap, vTexcoord);
        vBumpNormal = 2.0f * vBumpNormal - 1.0f;

        return mul(vBumpNormal, mTangentSpaceToWorldSpace);
    }

    //--------------------------------------------------------------------------------------
    // Diffuse lighting calculation, with angle and distance falloff.
    //--------------------------------------------------------------------------------------
    float4 CalcLightingColor(float3 vLightPos, float3 vLightDir, float4 vLightColor, float4 vFalloffs, float3 vPosWorld, float3 vPerPixelNormal)
    {
        float3 vLightToPixelUnNormalized = vPosWorld - vLightPos;

        // Dist falloff = 0 at vFalloffs.x, 1 at vFalloffs.x - vFalloffs.y
        float fDist = length(vLightToPixelUnNormalized);

        float fDistFalloff = saturate((vFalloffs.x - fDist) / vFalloffs.y);

        // Normalize from here on.
        float3 vLightToPixelNormalized = vLightToPixelUnNormalized / fDist;

        // Angle falloff = 0 at vFalloffs.z, 1 at vFalloffs.z - vFalloffs.w
        float fCosAngle = dot(vLightToPixelNormalized, vLightDir / length(vLightDir));
        float fAngleFalloff = saturate((fCosAngle - vFalloffs.z) / vFalloffs.w);

        // Diffuse contribution.
        float fNDotL = saturate(-dot(vLightToPixelNormalized, vPerPixelNormal));

        return vLightColor * fNDotL * fDistFalloff * fAngleFalloff;
    }

    //--------------------------------------------------------------------------------------
    // Test how much pixel is in shadow, using 2x2 percentage-closer filtering.
    //--------------------------------------------------------------------------------------
    float4 CalcUnshadowedAmountPCF2x2(int lightIndex, float4 vPosWorld)
    {
        // Compute pixel position in light space.
        float4 vLightSpacePos = vPosWorld;
        vLightSpacePos = mul(vLightSpacePos, lights[lightIndex].view);
        vLightSpacePos = mul(vLightSpacePos, lights[lightIndex].projection);

        vLightSpacePos.xyz /= vLightSpacePos.w;

        // Translate from homogeneous coords to texture coords.
        float2 vShadowTexCoord = 0.5f * vLightSpacePos.xy + 0.5f;
        vShadowTexCoord.y = 1.0f - vShadowTexCoord.y;

        // Depth bias to avoid pixel self-shadowing.
        float vLightSpaceDepth = vLightSpacePos.z - SHADOW_DEPTH_BIAS;

        // Find sub-pixel weights.
        float2 vShadowMapDims = float2(1280.0f, 720.0f); // need to keep in sync with .cpp file
        float4 vSubPixelCoords = float4(1.0f, 1.0f, 1.0f, 1.0f);
        vSubPixelCoords.xy = frac(vShadowMapDims * vShadowTexCoord);
        vSubPixelCoords.zw = 1.0f - vSubPixelCoords.xy;
        float4 vBilinearWeights = vSubPixelCoords.zxzx * vSubPixelCoords.wwyy;

        // 2x2 percentage closer filtering.
        float2 vTexelUnits = 1.0f / vShadowMapDims;
        float4 vShadowDepths;
        vShadowDepths.x = shadowMap.Sample(sampleClamp, vShadowTexCoord);
        vShadowDepths.y = shadowMap.Sample(sampleClamp, vShadowTexCoord + float2(vTexelUnits.x, 0.0f));
        vShadowDepths.z = shadowMap.Sample(sampleClamp, vShadowTexCoord + float2(0.0f, vTexelUnits.y));
        vShadowDepths.w = shadowMap.Sample(sampleClamp, vShadowTexCoord + vTexelUnits);

        // What weighted fraction of the 4 samples are nearer to the light than this pixel?
        float4 vShadowTests = (vShadowDepths >= vLightSpaceDepth) ? 1.0f : 0.0f;
        return dot(vBilinearWeights, vShadowTests);
    }

    PSInput VSMain(float3 position : POSITION, float3 normal : NORMAL, float2 uv : TEXCOORD0, float3 tangent : TANGENT)
    {
        PSInput result;

        float4 newPosition = float4(position, 1.0f);

        normal.z *= -1.0f;
        newPosition = mul(newPosition, model);

        result.worldpos = newPosition;

        newPosition = mul(newPosition, view);
        newPosition = mul(newPosition, projection);

        result.position = newPosition;
        result.uv = uv;
        result.normal = normal;
        result.tangent = tangent;

        return result;
    }

    float4 PSMain(PSInput input) : SV_TARGET
    {
        float4 diffuseColor = diffuseMap.Sample(sampleWrap, input.uv);
        float3 pixelNormal = CalcPerPixelNormal(input.uv, input.normal, input.tangent);
        float4 totalLight = ambientColor;
        
        for (int i = 0; i < NUM_LIGHTS; i++)
        {
            float4 lightPass = CalcLightingColor(lights[i].position, lights[i].direction, lights[i].color, lights[i].falloff, input.worldpos.xyz, pixelNormal);
            if (sampleShadowMap && i == 0)
            {
                lightPass *= CalcUnshadowedAmountPCF2x2(i, input.worldpos);
            }
            totalLight += lightPass;
        }

        return diffuseColor * saturate(totalLight);
    }
}

global(a, b) {
    Texture2D myTexture : register(t0);
    SamplerState samLinear : register(s0);

    cbuffer cbp : register(b1)
    {
      float4 fColor;
      float4 fTexelSize;
      int fRad;
    };

    float4 PShader(float4 position : SV_POSITION, float2 texcoord : TEXCOORD) : SV_TARGET
    {
      float4 frag=float4(0,0,0,0);
      int ext=(2*fRad+1);
      float2 tc=texcoord-fTexelSize.xy*fRad;
      [unroll(21)]
      for (int v=0;v<ext;v++)
      {
        frag=frag+myTexture.Sample(samLinear, tc)/ext;
        tc+=fTexelSize.xy;
      }
      if (frag.a == 0.0) discard;
      return frag;
    }
}

#pragma shader_version 		1.0
#pragma shader_language 	HLSL
#pragma cull 				BACK
#pragma front 				COUNTER_CLOCKWISE
#pragma topology			TRIANGLE
#pragma polygon 			FILL
#pragma line_width 			1.0
#pragma depth_test 			true
#pragma alpha_mode			OPAQUE

global(gbuffer, g_buffer_resolve)
{
	struct toto
	{
		float2 machin;
	};

	struct VsToFsStruct
	{
		float4 Pos 			: SV_Position;
		float3 Normal 	 	: NORMAL0;
		float2 UV 		 	: TEXCOORD0;
		float3 Color 	 	: COLOR0;
		float3 WorldPos 	: POSITION1;
		float3 Tangent 	 	: TEXCOORD1;
		toto   machin_test;
	};
};



vertex(test)
{

	float4 main(uint InstanceIndex : SV_InstanceID) : SV_Position
	{
		return float4(1,1,1,1);
	}

}
fragment(test)
{
	void main(float4 position)
	{
	}
}


vertex(gbuffer)
{
	struct VSInput
	{
		float4 Pos 		: POSITION0;
		float2 UV 		: TEXCOORD0;
		float3 Color 	: COLOR0;
		float3 Normal 	: NORMAL0;
		float3 Tangent 	: TEXCOORD1;
	};

	#include "ubo_definition.cg"

	VsToFsStruct main(VSInput input, uint InstanceIndex : SV_InstanceID)
	{
		VsToFsStruct output = (VsToFsStruct)0;
		float4 tmpPos = input.Pos + ubo.instancePos[InstanceIndex];

		output.Pos = mul(ubo.projection, mul(ubo.view, mul(ubo.model, tmpPos)));

		output.UV = input.UV;

		// Vertex position in world space
		output.WorldPos = mul(ubo.model, tmpPos).xyz;

		// Normal in world space
		output.Normal = normalize(input.Normal);
		output.Tangent = normalize(input.Tangent);
		
		// Currently just vertex color
		output.Color = input.Color;
		return output;
	}

    VsToFsStruct main2(uint vertex_index : SV_VertexID)
    {
        VsToFsStruct output;
        output.Uv = float2((vertex_index << 1) & 2, vertex_index & 2);
        output.Pos = float4(output.Uv * 2.0f - 1.0f, 0.0f, 1.0f);
        output.Uv *= float2(1, -1);
        return output;
    }

};

#pragma shader_language HLSL
#pragma FRONT_FACE 		CLOCKWISE
#pragma CULL 			NONE
#pragma ALPHA_MODE		TRANSLUCENT

global(imgui_render_pass)
{
	struct VsToFs 
	{
		float4 Pos 		: SV_Position;
		float4 Color 	: COLOR;
		float2 UV 	 	: TEXCOORD;
	};
}

vertex(imgui_render_pass)
{
	struct VSInput
	{
		float2 aPos 	: POSITION;
		float2 aUV 		: TEXCOORD;
		float4 aColor 	: COLOR;
	};
	
	struct PushConsts 
	{
		float2 uScale;
		float2 uTranslate;
	};
	ConstantBuffer<PushConsts> pc;
	
	VsToFs main(VSInput input)
	{
		VsToFs Out;
		Out.Color	= input.aColor;
		Out.UV 		= input.aUV;
		Out.Pos 	= float4(input.aPos * pc.uScale + pc.uTranslate, 0, 1);
		return Out;
	}
}

fragment(imgui_render_pass)
{
	Texture2D	 sTexture;
	SamplerState sSampler;

	float4 main(VsToFs input) : SV_TARGET
	{
		return input.Color * sTexture.Sample(sSampler, input.UV);
	}
}

#pragma shader_language HLSL
#pragma CULL            NONE

global(surface_pass, deferred_combine)
{
    struct VsToFsStruct
    {
        float4 Pos : SV_Position;
        float2 Uv : TEXCOORD;
    };
}

vertex(surface_pass, deferred_combine) 
{
    VsToFsStruct main(uint vertex_index : SV_VertexID)
    {
        VsToFsStruct output;
        float2 uv = float2((vertex_index << 1) & 2, vertex_index & 2);
        output.Pos = float4(uv * 2.0f - 1.0f, 0.0f, 1.0f);
        output.Uv = uv * float2(1, -1);
        return output;
    }
}

fragment(surface_pass, deferred_combine)
{
	struct PushConsts 
	{
		float time;
	};
	ConstantBuffer<PushConsts> pc;
}

fragment(surface_pass)
{
    SamplerState global_sampler;
    Texture2D ui_result;
    Texture2D scene_result;
    
    float4 main(VsToFsStruct input) : SV_Target
    {
        float4 ui = ui_result.Sample(global_sampler, input.Uv);
        float4 scene = scene_result.Sample(global_sampler, input.Uv);
        return lerp(ui, scene, ui.a) + float4(0, 0, 0, pc.time);
    }
}

fragment(deferred_combine)
{
    SamplerState global_sampler;
    Texture2D bg_texture;
    
    float4 main(VsToFsStruct input) : SV_Target
    {
        return bg_texture.Sample(global_sampler, input.Uv) + float4(0, 0, 0, pc.time);
    }
}


// fragment(gbuffer) => "demo_fragment.shb"
