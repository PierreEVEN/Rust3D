use std::hash::{Hash, Hasher};
use std::sync::{Arc, RwLock};
use logger::{fatal};
use maths::vec2::Vec2u32;
use crate::Gfx;
use crate::image::{GfxImage, ImageCreateInfos, ImageParams, ImageType};
use crate::image::ImageUsage::GpuWriteDestination;
use crate::renderer::frame_graph::FrameGraph;
use crate::renderer::render_pass::RenderPass;
use crate::renderer::renderer_resource::{Resource, ResourceColor, ResourceDepth};
use crate::renderer::renderer_resource::Resource::{Color, Depth};
use crate::surface::GfxSurface;

/// This is a single node of a render graph. 
/// It contains an array of nodes that will require the resources generated by this pass
/// In other words :
/// ```
/// use gfx::renderer::render_node::RenderNode;
/// 
/// let mut parent = RenderNode::default();
/// let child = RenderNode::default();
/// parent.attach(std::sync::Arc::new(child))
/// ```
/// will make child.resources available to parent
pub struct RenderNode {
    name: String,
    inputs: Vec<Arc<RenderNode>>,
    resources: Vec<Resource>,
    compute_res: Arc<RwLock<dyn FnMut(Vec2u32) -> Vec2u32>>,
    present_pass: bool,
}

impl Default for RenderNode {
    fn default() -> Self {
        Self {
            name: "unknown_pass".to_string(),
            inputs: vec![],
            resources: vec![],
            compute_res: Arc::new(RwLock::new(|res| { res })),
            present_pass: false,
        }
    }
}

impl RenderNode {
    /// Create a default Render Node for present usage
    pub fn present() -> Self {
        Self {
            name: "PresentPass".to_string(),
            inputs: vec![],
            resources: vec![],
            compute_res: Arc::new(RwLock::new(|res| { res })),
            present_pass: true,
        }
    }
    
    /// Retrieve color resources of this pass
    pub fn color_resources(&self) -> Vec<ResourceColor> {
        let mut resources = vec![];
        for resource in &self.resources {
            if let Color(color) = resource {
                resources.push(color.clone());
            }
        }
        resources
    }

    /// Retrieve depth resources of this pass
    pub fn depth_resource(&self) -> Vec<ResourceDepth> {
        let mut resources = vec![];
        for resource in &self.resources {
            if let Depth(depth) = resource {
                resources.push(depth.clone());
            }
        }
        resources
    }
    
    pub fn is_present_pass(&self) -> bool { self.present_pass }

    pub fn attach(&mut self, previous: Arc<RenderNode>) {
        if previous.present_pass {
            fatal!("Present pass cannot be attached to parent pass");
        }
        self.inputs.push(previous);
    }

    pub fn name(mut self, name: &str) -> Self {
        self.name = name.to_string();
        self
    }

    pub fn get_name(&self) -> &String {
        &self.name
    }
    
    pub fn res_override<H: FnMut(Vec2u32) -> Vec2u32 + 'static>(mut self, func: H) {
        self.compute_res = Arc::new(RwLock::new(func));
    }

    pub fn add_resource(mut self, resource: Resource) -> Self {
        self.resources.push(resource);
        self
    }
    
    pub fn compute_res(&self) -> &Arc<RwLock<dyn FnMut(Vec2u32) -> Vec2u32>> {
        &self.compute_res        
    }
     
    /// Create a RenderPass from this node
    fn compile_item(instance: &mut RenderPass, render_passes: &RenderNode, initial_res: Vec2u32) {
        for input in &render_passes.inputs {
            
            // Create resources
            // TODO : reuse resources across passes
            let mut images = vec![];
            for resource in &input.resources {
                images.push(Gfx::get().create_image(
                    resource.name().clone(),
                    ImageCreateInfos { params: ImageParams {
                        pixel_format: *resource.format(),
                        image_type: ImageType::Texture2d(initial_res.x, initial_res.y),
                        read_only: false,
                        mip_levels: None,
                        usage: enumflags2::BitFlags::from_flag(GpuWriteDestination),
                    }, pixels: None },
                ))
            }
            
            let mut new_instance = RenderPass::new(images, input, initial_res);
            Self::compile_item(&mut new_instance, input, initial_res);
            instance.add_input(Arc::new(new_instance));
        }
    }

    /// Compile this graph of RenderPass to a FrameGraph (for surfaces)
    pub fn compile_to_surface(&self, surface: Box<dyn GfxSurface>) -> FrameGraph {
        if !self.present_pass { fatal!("Only present pass can be compiled to surface") }
        let initial_res = surface.get_surface_texture().res_2d();
        let mut framegraph = FrameGraph::new_surface(surface, 3);
        Self::compile_item(framegraph.present_pass(), self, initial_res);
        framegraph
    }

    /// Compile this graph of RenderPass to a FrameGraph (for surfaces)
    pub fn compile_to_image(&self, image: Arc<dyn GfxImage>) -> FrameGraph {
        if !self.present_pass { fatal!("Only present pass can be compiled to surface") }
        let initial_res = image.res_2d();
        let mut framegraph = FrameGraph::new_image(image, 3);
        Self::compile_item(framegraph.present_pass(), self, initial_res);
        framegraph
    }
}

impl Hash for RenderNode {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.resources.hash(state);
    }
}

impl PartialEq for RenderNode {
    fn eq(&self, other: &Self) -> bool {
        self.resources == other.resources
    }
}

impl Eq for RenderNode {}